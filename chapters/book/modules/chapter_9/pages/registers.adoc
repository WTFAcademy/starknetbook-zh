[id="registers"]

= 寄存器

我们知道，代数RISC（简约指令集计算机）是操作内存单元的（没有通用目的寄存器）。一条 Cairo 指令可能需要处理多达 3 个内存中的值：它可以对其中两个执行一种算术运算（加法或乘法），并将结果存储在第三个中。总的来说，每条指令使用 4 次内存访问，因为它首先使用一次来获取指令（https://eprint.iacr.org/2021/1063.pdf[Cairo 白皮书]）。

Cairo CPU 操作 3 个寄存器（`pc`、`ap` 和 `fp`），它们用于指定指令操作的内存单元。对于指令中的每个 3 个值，您可以选择形式为 $ap + off$ 或 $fp + off$ 的地址，其中 $off$ 是范围在 $[−215, 215)$ 的常数偏移量。因此，一条指令可能涉及到 $2 · 216 = 131072$ 中的任何 3 个内存单元。在许多方面，这与拥有这么多寄存器（以更便宜的方式实现）相似。偏移量是对内存中的单元的增加或减少，例如，$[fp - 1] = [ap - 2] + [fp + 4]$，其中 $-1$、$-2$ 和 $+4$ 是偏移量。偏移量使我们能够具有相对内存位置。

* "分配指针"（ap）指向到目前为止程序尚未使用的第一个内存单元。许多指令可能会将 `ap` 的值增加一，以表示另一个内存单元已被指令使用；这类似于当它使用 `output_ptr` 上的输出内置内存并然后更新其值时，`serialize_word` 所做的事情。
* 当函数开始时，"帧指针"寄存器（fp）被初始化为 ap 的当前值。在整个函数的范围内（排除内部函数调用），`fp` 的值保持不变。具体来说，当函数 foo 调用一个内部函数 bar 时，`fp` 的值在 bar 开始时改变，但在 bar 结束时恢复。这个想法是，当调用内部函数时，`ap` 可能会以未知的方式变化，因此在此之后，它不能可靠地用于访问原始函数的局部变量和参数。因此，`fp` 用作访问这些值的锚点。
* "`程序计数器`"（pc）寄存器指向要执行的当前 Cairo 指令在内存中的地址。`pc` 从程序段的开始处开始；段 0。CPU（1）获取该内存单元的

值，（2）执行由该值表示的指令（可能影响内存单元或通过为 PC 分配不同的值来改变程序的流程），（3）将 `pc` 移动到下一条指令，然后（4）重复此过程。换句话说，程序计数器（pc）保持当前指令的地址。通常，它根据指令的大小每条指令进步 1 或 2（当当前指令占用两个字段元素时，程序计数器对于下一条指令前进 2）。

编译并运行链接：registers/cairo/ap_fp_example.cairo[registers/cairo/ap_fp_example.cairo]。示例将打印：

[,Bash]
----
1. ap 地址：1:3；fp 地址：1:3
2. ap 地址：1:4；fp 地址：1:3；地址 [AP - 1] 的值为 100。
3. ap 地址：1:5；fp 地址：1:3；地址 [AP - 1] 的值为 200。
4. ap 地址：1:6；fp 地址：1:3；地址 [AP - 1] 的值为 2:0（带有 OUTPUT_PTR）。
5. ap 地址：1:9；fp 地址：1:8；地址 [AP - 1] 的值为 300（FOO() 函数）。
6. ap 地址：1:9；fp 地址：1:8；地址 [AP + 2] 的值为 500；我们无法获取 [AP + 1] 的值，因为它是未知的。
7. ap 地址：1:10；fp 地址：1:3；地址 [AP - 1] 的值为 600。
----

注意：

. `fp` 在函数范围开始时初始化为 `ap` 在那时采用的相同值：在 `main` 的范围期间，它是 `1:3`，在 `foo` 的范围期间，它是 `1:8`。当 `foo` 的范围结束并且程序返回到 `main` 时，`fp` 再次为 `1:3`。
. 您可以跳过内存单元。在指令 6 中，我们设置了 `[ap+2]` 的值，而没有定义 `[ap+1]`。
. `[ap]` 可以存储 felts，但也可以存储可重定位的地址，就像在指令 4 中，我们存储了 `output_ptr` 的值。
. `ap` 一次前进一，除非调用了函数，以及在开始时。我们的 `ap` 开始指向 1:3，因为执行段的前三个内存单元（1:0，1:1，1:2）指示将要使用的其他段，本例中是段 2，3 和 4。段 2 用于输出内置，段 3 和 4 是空段，用于返回 `fp` 和 pc 的返回值。

运行链接：registers

/cairo/ap_fp_example.cairo[registers/cairo/ap_fp_example.cairo]，带有标志 `--print_info` 和 `--print_segments`。
注意：

. 多亏了 `--print_info`，我们可以看到执行后的寄存器值。

[,Bash]
----
执行后的寄存器值：
pc = 4:0
ap = 1:11
fp = 3:0
----

寄存器的最终值也是可重定位的。`ap` 保持在执行段（1），而 `fp` 和 `pc` 的返回值由于技术原因分配了它们自己的段。

. 多亏了 `--print_segments`，我们可以看到段重定位表；

[,Bash]
----
段重定位表：
0     1
1     29
2     339
3     340
4     340
----

该表显示了每个段重定位后使用的内存单元的实际（不是相对的）地址。段 3-4 是空段，用于返回 `fp` 和 `pc` 的值。如你所见，内存最终是连续的：例如，段 1 在段 0 结束时的单元 29 处开始，并继续到单元 338，记住我们将值设置为 `[ap+300]`，因此单元 40-337 被证明者自动填充。然后，段 2 在下一个地址，339，开始。

[附注]
====
《Starknet 之书》是 Starknet 社区成员合力之作，便于社区成员学习之用。

* 无论你是否有所收获，烦请填写此问卷， https://a.sprig.com/WTRtdlh2VUlja09lfnNpZDo4MTQyYTlmMy03NzdkLTQ0NDEtOTBiZC01ZjAyNDU0ZDgxMzU=[简单回答三个问题] ，给予我们反馈。
* 若发现任何错误，或有其他建议，请在我们的 https://github.com/starknet-edu/starknetbook/issues[Github 仓库]发起问题单 (Issues)。
====



== 贡献力量

[quote, Starknet 社区]

____

释放你的热情，让《Starknet 之书》更加完美

《Starknet 之书》依然在不断完善中，而你的热情、专业知识和独到见解可以将它塑造成一部真正卓越的作品。不要害怕挑战现状或是颠覆这本书！齐心协力，我们一起创造这份宝贵的资源，造福无数人。

为公共事业贡献力量。如果你发现本书有改进的空间，那就抓住机会吧！查看我们的https://github.com/starknet-edu/starknetbook/blob/main/CONTRIBUTING.adoc[指南]并加入活力满满的社区。一起无畏共建 Starknet！

____