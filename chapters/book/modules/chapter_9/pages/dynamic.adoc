[id="dynamic"]
= 内置函数和动态布局

== 更高效的证明任务之路

内置函数优化了证明过程。然而，每个证明都是相对于布局计算的，而对于特定的证明任务来说，不高效的布局会减少内置函数的效益。目前，有一个小的静态布局列表，每个证明都是相对于该列表中最合适的布局进行计算的。静态方法有两个主要缺点。首先，布局的有限变化对大多数证明任务来说是低效的，通过复杂的费用机制对用户造成了不必要的开销。其次，为了适应新的内置函数，手动维护列表变得更加困难，几乎阻碍了证明过程支持许多内置函数的效率。为了解决这些问题，我们正在开发一个动态布局系统，其中布局根据每个证明任务进行定制。

Cairo 堆栈通过将 Cairo 代码编译成适合 STARK-friendly 的 CPU 架构的指令，实现了可证明的通用计算：Cairo 虚拟机（以下简称 CVM）。通用 CPU 的许多优点带来了内在的成本：CVM 并未针对许多常用操作进行优化。这些操作的显著例子包括哈希函数，例如 Keccak、Pedersen 和 Poseidon，其他例子包括椭圆曲线操作和范围检查（即检查特定数值是否在特定范围内）。

为了解决 CVM 的相对低效问题，Cairo 堆栈引入了针对关键操作的内置函数概念：优化这些操作的证明复杂性的插件。内置函数类似于 ASIC：ASIC 是特定应用集成电路，而内置函数是特定应用代数约束（AIR）。如果你不知道或者不记得什么是 AIR，我们稍后会简单提及；更多的细节请看 link:https://medium.com/starkware/arithmetization-i-15c046390862[这篇初级的 Medium 文章]。

简单来说，证明复杂性与称为追踪单元的资源大致线性相关，内置函数通过使用比 Cairo VM 更少的追踪单元来优化特定操作的证明。

解释了内置函数的好处后，为许多常用操作开发它们似乎是自然的。但这比说起来要难。将新的内置函数引入 Starknet 的当前过程涉及几个步骤：

1. 写出 AIR
2. 通过创建新的布局（如下解释）将其整合到证明者中
3. 将其整合到 Starknet 中，即修改其代码库和

开发者工具以使用新的内置函数

除了编写 AIR 的挑战之外，在剩下的两个阶段还有很大的改进空间。这篇高级的文章将详细介绍内置函数作为特定应用的 AIR，上述问题，以及我们未来的计划。

== 内置函数：特定应用的 AIR

AIR 是 Algebraic Intermediate Representation 的缩写。在我们的上下文中，它是一个表示虚拟机的多项式系统。例如，Cairo 从 CPU AIR 得名：一个表示特定 CPU 架构的多项式系统。这个多项式系统的解代表了一个有效的状态转换，被称为有效的代数执行迹线（AET）。

STARK 通过证明相关的执行迹线相对于给定的 AIR 有效来证明虚拟机的正确操作。粗略地说，执行迹线被组织为数字表格，STARK 协议证明这些数字共同解决了一个多项式系统。

有许多方法可以计算同样的事情，有些计算比其他的更有效。在我们的上下文中，证明复杂性基本上由迹线大小决定，即表格中的迹线单元数量。由于迹线是根据 AIR 生成的，所以特定应用的 AIR 可以大大减少特定计算的执行迹线。内置函数就是针对这种优化的特定应用的 AIR。

下面是一个表格，展示了特定内置函数（全部在生产中）的效率改进。

image::builtin.png[builtin]

== 迹线布局：现在和未来

回忆一下，代数执行迹线（AET）粗略来说是一个编码了 VM 步骤序列（即程序执行）的数字表格。为了计算证明，证明者对一个与 AIR 相关的执行迹线执行 STARK 协议。

上面，我们将内置函数引入为特定应用的 AIR，旨在通过减少编码计算所需的迹线单元的数量，最小化证明复杂性。然而，将内置函数粗心地整合到 Starknet 可以浪费许多迹线单元，降低了预期的效益。我们来详细说明。

简单来说，迹线布局是将迹线单元分配给不同“组件”的配置。在我们的上下文中，这些组件是 CVM 和内置函数。更具体地说，布局指定了为每个组件分配的迹线单元的相对数量。（布局总是被组织为优化证明验证。有关更多信息，请查看 "succinctness" link:https://medium.com/starkware/arithmetization-ii-403c3b3f4355[这篇 Medium 文章中的部分]。）

这里是关键点：证明

复杂性取决于布局分配的迹线单元的总数，这可能比必要的大。例如，为了证明一系列 CVM 步骤，使用只为 CVM 组件分配迹线单元的布局大致上比使用将一半迹线单元分配给例如 Poseidon 内置函数的布局更有效。总的来说，通过适当的布局，可以大大降低证明特定计算的复杂性。

目前，有一个手动维护的布局列表，主要因两个原因而逐渐增长：

1. 内置函数只能在为它们分配迹线单元的布局中使用。因此，添加一个内置函数需要至少一个新的布局。
2. 根据 Cairo 代码的执行情况定制布局可以改进单元分配。因此，优化单元利用率通常需要新的布局。

证明者和验证者的代码（Solidity 和 Cairo 验证者）根据布局列表进行配置。

随着 Keccak 和 Poseidon 内置函数的增加，我们发现生成一个包含许多内置函数的小布局列表的难度越来越大，同时还能保持执行大多数 Starknet 区块的高效性。此外，随着更多内置函数的引入，这种效率预计会大幅度下降，因为布局必须考虑到它们之间的许多可能的组合和比例。

我们目前正在努力改进我们的系统，并放弃预先指定的布局列表，转而采用“动态布局”：根据每一次 Cairo 代码的执行情况进行定制。动态布局总是会为手头的证明工作提供最优的比例。从工程角度来看，这需要在代码库中进行大量的更改以支持动态输入。然而，我们预计动态布局将通过改进迹线单元的使用和 consequently 更好地利用证明机器来优化 Starknet 的证明层。

动态布局将解决手动维护许多内置函数的高效布局的挑战，因此简化了将更多内置函数集成到 Starknet 的过程。

== 动态布局和费用

交易费用的一个目标是向用户收取由他们的交易在协议上产生的边际成本。由于交易费用的单位是货币，所以费用机制涉及将资源（例如 VM 步骤、内置函数、 calldata、Ethereum gas）转化为代币（例如 STRK、ETH）。

目前，证明者的资源浪费导致用户负担过重，因为他们按照总迹线收取费用，而不是其使用部分。动态布局将改善单元利用率，consequently 减少交易费用的

总量。

然而，提高资源利用率并不能让费用完全公平。这是因为，虽然证明复杂性大致线性地取决于迹线单元的数量，但每个单位的边际成本可能因组件而异。例如，为 Poseidon 赋值的单元可能比为 CVM 赋值的单元更昂贵。

在当前的费用机制中，所有单位的价格都是相同的，这可能导致一些交易对系统资源的消耗超过其支付的费用。我们计划根据资源类型对单位价格进行区分，以更好地反映其在证明过程中的边际成本。我们将通过观察历史证明来确定这些价格。

== 结论

我们正在开发一个系统，使证明层能够更好地利用资源，同时简化更多内置函数的引入过程。我们还在改进费用机制，以更好地反映交易对资源的消耗。这些改进将降低 Starknet 的运营成本，从而为用户和开发者带来利益。

[附注]
====
《Starknet 之书》是 Starknet 社区成员合力之作，便于社区成员学习之用。

* 无论你是否有所收获，烦请填写此问卷， https://a.sprig.com/WTRtdlh2VUlja09lfnNpZDo4MTQyYTlmMy03NzdkLTQ0NDEtOTBiZC01ZjAyNDU0ZDgxMzU=[简单回答三个问题] ，给予我们反馈。
* 若发现任何错误，或有其他建议，请在我们的 https://github.com/starknet-edu/starknetbook/issues[Github 仓库]发起问题单 (Issues)。
====



== 贡献力量

[quote, Starknet 社区]

____

释放你的热情，让《Starknet 之书》更加完美

《Starknet 之书》依然在不断完善中，而你的热情、专业知识和独到见解可以将它塑造成一部真正卓越的作品。不要害怕挑战现状或是颠覆这本书！齐心协力，我们一起创造这份宝贵的资源，造福无数人。

为公共事业贡献力量。如果你发现本书有改进的空间，那就抓住机会吧！查看我们的https://github.com/starknet-edu/starknetbook/blob/main/CONTRIBUTING.adoc[指南]并加入活力满满的社区。一起无畏共建 Starknet！

____