[id="low_testing"]

= 低度测试：简洁的秘诀

算术化的过程使我们能够将计算完整性（ CI ）问题简化为低度测试问题。低度测试是指通过对函数进行少量查询，来判断给定函数是否为某个受限度数的多项式的问题。低度测试已经被研究了二十多年，是概率证明理论中的核心工具。本文的目的是更详细地解释低度测试，并描述我们在 STARK 中用于低度测试的协议 FRI。本文假定读者熟悉有限域上的多项式。

在我们讨论低度测试之前，我们先通过一个稍微简单的问题来进行热身：给定一个函数，并要求我们通过在“少量”位置上查询该函数，来判断这个函数是否等于某个常数d 的多项式。正式地说，给定域 F 的子集 L 和受限度数 d，我们希望确定 $f:L➝F$ 是否等于度数小于 $d$ 的多项式，即是否存在一个多项式。

image::low1.png[low1]

其存在于域 $F$ 上，对于$L$中的每个$a$，$p(a)=f(a)$。对于具体的数值，你可以考虑一个规模非常大的域，比如2¹²⁸$，而 $L$ 的规模大约为10,000,000。

解决此问题需要在整个域 $L$ 中查询 $f$，因为 f 可能与 $L$ 的任何地方的多项式一致，除了一个位置之外。即使我们允许恒定的错误概率，查询的数量仍然与 $L$ 的大小成线性关系。

[cols=3*]
|===
| 为此，低度测试问题实际上是对上述问题的一种近似放宽，它足以构造概率证明，也可以用查询次数来解决，查询次数的对数是$
| L
| $（请注意，如果 $L≈10,000,000$，则 $log₂(L)≈23）$。更详细地说，我们希望区分以下两种情况。
|===

* *函数 $f$ 等于一个低度多项式。*。也就是说，存在一个多项式 $p(x)$ 在 $F$ 上，度数小于 $d$，并且在 $L$ 上处处与 $f$ 一致。
* *函数 $f$ 与所有低度多项式相差甚远*。 例如，我们需要修改至少 10% 的 $f$ 值，才能获得一个符合小于 $d$ 的多项式的函数。

请注意，还有另一种可能性 -- 函数 $f$ 可能略微接近低度多项式，但不等于 1。例如，一个 $5%$ 的值与低度多项式不同的函数，不属于上述两种情况中的任何一种。然而，先前的算术化步骤（在我们之前的帖子中讨论过）确保第三种情况永远不会出现。更详细地说，算术化表明处理真实声明的诚实证明器将落入第一种情况，而试图“证明”错误声明的（可能是恶意的）证明器将很有可能落入第二种情况。

为了区分这两种情况，我们将使用一个概率多项式时间测试，在少量位置查询 f（我们稍后讨论“少量”的含义）。

[cols=3*]
|===
| | 这一段是可有可无的，主要用于理解全局。如果 $f$ 确实是低度的，那么测试应该以 1 的概率接受。如果 f 远非低度，那么测试应该以高概率拒绝。更通俗地说，我们寻求保证，如果 f 与任何度数小于 d 的函数 $δ-相差$（即必须修改至少 $δ
| L
| $ 的位置以获得度数小于 d 的多项式），然后该测试以至少 $Ω(δ)$ 的概率拒绝（或 $δ$ 的一些其他“好”函数）。直觉上，$δ$ 越接近零，就越难区分这两种情况。
|===

在接下来的几节中，我们描述了一个简单的测试，然后解释了为什么它在我们的设置中不够用，最后我们描述了一个效率成倍增加的、更复杂的测试。后一种测试是我们在 STARK 中使用的测试。

== 直接测试

[cols=3*]
|===
| 我们考虑的第一个测试很简单：它使用 $d+1$ 查询来测试函数是否（接近）度数小于 $d$ 的多项式。这个测试依赖于有关多项式的一个基本事实：任何度数小于 d 的多项式完全由它在 $F$ 的任何 d 个不同位置的值决定。这个事实是一个直接的结果，即一个度数为 $k$ 的多项式在 $F$ 中最多可以有 $k$的根。重要的是，查询的数量，即 $d+1$，可以明显小于 $f$ 的域大小，即 $
| L
| $。
|===

我们首先讨论两个简单的特殊情况，以建立对测试在一般情况下如何工作的直觉。

* *常数函数 $(d=1)$ 的情况。* 这对应于区分 $f$ 是常数函数的情况（$f(x)=c$ for some $c$ in $F$）和 $f$ 远离任何常数函数的情况功能。在这种特殊情况下，有一个自然的 2 次查询测试可能有效：在固定位置 $z1$ 和随机位置 $w$ 查询 $f$，然后检查 $f(z1)=f(w )$。直观地说，$f(z1)$ 决定了 $f$ 的（所谓的）常数值，$f(w)$ 测试是否所有的 $f$ 都接近这个常数值。
* *线性函数 $(d=2)$ 的情况。* 这对应于区分 $f$ 是线性函数的情况（$f(x)=ax+b$ for some $a$,$b$ in $F$）和 $f$ 远离任何线性函数的情况。在这种特殊情况下，有一个自然的 3 次查询测试可能有效：在两个固定位置 z1、z2 和随机位置 $w$ 查询 f，然后检查 ($z1$,$f(z1)$ ), ($z2$,$f(z2)$)、($w$,$f(w)$) 是否成线性，即可以通过这些点将其贯穿成一条线。直观地说，$f(z1)$ 和 $f(z2)$ 的值决定了（所谓的）线，而 $f(w)$ 测试了 $f$ 的全部是否接近这条线。

上述特殊情况提示了一种针对受限度数 $d$ 的通用情况进行测试。在 $d$ 次固定位置 $z1$、$z2$、$… $、$zd$ 以及随机位置 $w$ 处查询 $f$。 $f$ 在 $z0$,$z1$,$… $,$zd$ 的值定义了一个唯一的多项式 $h(x)$，其度数小于 $d$，超过 $F$，与 $f$在这些点上保持一致。然后测试检查 $h(w)=f(w)$。我们称之为直接测试。

根据定义，如果 $f(x)$ 等于次数小于 $d$ 的多项式 $p(x)$，则 $h(x)$ 将与 $p(x)$ 完全相同，因此直接测试以概率 1 通过。此属性称为“完美完整性”，这意味着此测试只有单边误差。

我们要争论的是，如果$f$与任何度数小于 $d$ 的函数相差 $δ$，会发生什么情况（例如，考虑 $δ=10%$。）我们现在要争论的是，在这种情况下，直接测试以至少 δ 的概率拒绝。事实上，设 𝞵 是随机选择 w，则 $h(w)≠f(w)$。我们观察到 $𝞵$ 必须至少为 δ。可选的：这是因为如果我们假设 𝞵 小于 δ，那么我们推断 f 是 δ 接近 h，这与我们假设 f 是 δ 远离任何小于 d 的函数的假设相矛盾。

== 直接测试对我们来说并不够

在我们的设置中，我们对测试编码计算轨迹的函数 f:L➝F 感兴趣，因此其度数 d（和域 L）非常大。仅运行直接测试，即进行 d+1 次查询的成本太高。为了获得 STARK 的指数级节省（与计算轨迹的大小相比，验证时间），我们需要仅使用 O(log d) 个查询来解决这个问题，这比受限度数 d 要少的多。

不幸的是，这是不可能的，因为如果我们在少于 d+1 个位置查询 f，那么我们无法得出任何结论。

可选的：查看此问题的一种方法是考虑函数 f:L➝F 的两种不同分布。在一个分布中，我们统一选择一个度数恰好为 d 的多项式并在 L 上对其进行评估。在另一个分布中，我们统一选择一个度数小于 d 的多项式并在 L 上对其进行评估。在这两种情况下，对于任何 d 位置 z1，z2， ...,zd，值 f(z1),f(z2),...,f(zd) 都均匀且独立分布。 （我们将这个事实留给读者作为练习。）这意味着从信息理论上讲，我们无法区分这两种情况，即使测试需要这样做（因为来自第一个分布的多项式应该被测试接受，而那些度数正好为 d 的多项式与所有度数小于 d 的多项式相去甚远，因此应该被拒绝）。

我们似乎有一个艰难的挑战需要克服。

== 让证明器来解救

我们已经看到，我们需要 d+1 个查询来测试函数 f:L➝F 是否接近度数小于 d 的多项式，但我们负担不起这么多查询。我们通过考虑稍微不同的设置来避免这种限制，这对我们来说已经足够了。即，当证明器可提供有关函数 f 的有用辅助信息时，我们考虑低度测试问题。我们将看到，在这种低度测试的“证明器辅助”设置中，我们可以实现查询数量的指数级改进，达到 O(log d)。

更详细地说，我们考虑在证明器和验证者之间执行的协议，其中（不受信任的）证明器试图说服验证者相信该函数是低度的。一方面，证明器知道被测试的整个函数 f。另一方面，验证者可以在少数位置查询函数 f，并愿意接受证明器的帮助，但不相信证明器是诚实的。这意味着证明器可能会作弊并且不遵守协议。但是，如果证明器确实作弊，则无论函数 f 是否为低度，验证者都有权“拒绝”。这里的重点是验证者不会相信 f 是低度的，除非这是真的。

请注意，上面描述的直接测试只是协议的一个特例，在这个特例中，证明器什么都不做，而验证者独立测试功能。为了比直接测试做得更好，我们需要以某种有意义的方式利用证明器的帮助。

在整个协议中，证明器将希望使验证者能够在验证者选择的位置上查询辅助功能。这可以通过承诺来实现，我们将在以后的文章中讨论这个机制。现在我们只需要说明，证明器可以通过 Merkle 树提交其选择的函数就足够了，随后验证者可以请求证明器揭示提交函数的任何位置集。这种承诺机制的主要特性是，一旦证明器承诺了一个函数，它必须揭示正确的值，并且不能作弊（例如，它不能在看到验证者的请求后决定函数的值是什么）。

== 在处理两个多项式的情况下，查询次数减半

让我们从一个简单的例子开始，该例子说明证明器如何帮助将查询数量减少 2 倍。我们稍后将在此例子的基础上进行构建。假设我们有两个多项式 f 和 g，我们想测试它们的度数是否都小于 d。如果我们简单地对 f 和 g 单独运行直接测试，那么我们将需要进行 2 * (d + 1) 次查询。下面我们将介绍如何在证明器的帮助下，将查询的数量减少到 (d + 1) 加上一个更小阶的项。

首先，验证者从域中随机选择一个值 𝛼，并将其发送给证明器。接下来，证明器通过承诺在域 L 上评估对多项式 h(x) = f(x) + 𝛼 g(x)（换句话说，证明器将计算并发送 Merkle 树的根，其叶子是 L 上 h 的值）。验证者现在通过直接测试测试 h 的度数是否小于 d，这需要 d+1 次查询。

[cols=5*]
|===
| 直观地说，如果 f 或 g 的度数至少为 d 那么 h 的度数很可能也是如此。例如，考虑 f 中 xⁿ 的系数对于某些 n≥d 不为零的情况。那么，至多有一个𝛼（由验证者发送）的选择，其中 xⁿ 在 h 中的系数为零，这意味着 h 的度数小于 d 的概率大致为1/
| F
| 。如果域足够大（例如，
| F
| >2¹²⁸ 出错的概率可以忽略不计。
|===

然而，情况并没有这么简单。原因是，正如我们所解释的，我们无法从字面上检查 h 是度数小于 d 的多项式。相反，我们只能检查 h 是否接近这样的多项式。这意味着上面的分析是不准确的。是否有可能 f 远离低度多项式，而线性组合 h 以不可忽略的概率接近于𝛼？在温和的条件下，答案是否定的（这是我们想要的），但这超出了本文的范围；我们建议有兴趣的读者阅读 https://acmccs.github.io/papers/p2087-amesA.pdf[这篇文章] 和 https://eccc.weizmann.ac.il/report/2017/134/[这篇文章].

此外，验证者如何知道证明器发送的多项式 h 具有 f(x)𝛼 g(x) 的形式？恶意证明器可能会发送一个确实是低度但与验证者要求的线性组合不同的多项式来作弊。如果我们已经知道 h 接近于一个低度多项式，那么测试这个低度多项式是否具有正确的形式就很简单了：验证者在 L 中随机抽取一个位置 z，查询 z 处的 f、g、h，并检查方程 h(z)=f(z)𝛼 g(z) 成立。该测试应重复多次，以提高测试的准确性，但误差会随着我们制作的样本数量的增加而呈指数级减少。因此，此步骤仅通过较小的阶项增加了查询的数量（到目前为止是 d+1）。

== 将一个多项式拆分为两个小度数的多项式

我们看到，在证明器的帮助下，我们可以通过少于 2*(d+1) 次查询来测试两个多项式的度数是否小于 d。我们现在描述如何将一个度数小于 d 的多项式变成两个度数小于 d/2 的多项式。

设 f(x) 是度数小于 d 的多项式，并假设 d 是偶数（在我们的设置中，这是不失一般性）。对于度数小于 d/2 的两个多项式 g(x) 和 h(x)，我们可以写成 f(x)=g(x²)+xh(x²)。事实上，我们可以让 g(x) 成为从 f(x) 的偶数系数得到的多项式，而 h(x) 成为从 f(x) 的奇数系数得到的多项式。例如，如果 d=6 我们可以写成

image::smallerPol1.png[smallerPol1]

这意味着

image::smallerPol2.png[smallerPol2]

以及

image::smallerPol3.png[smallerPol3]

这是用于多项式评估的 n*log(n) 算法（改进了朴素的 n2 算法）。

[NOTE]
====
《Starknet 之书》是 Starknet 社区成员合力之作，便于社区成员学习只用。

* 无论你是否有所收获，烦请填写此问卷，简单回答 https://a.sprig.com/WTRtdlh2VUlja09lfnNpZDo4MTQyYTlmMy03NzdkLTQ0NDEtOTBiZC01ZjAyNDU0ZDgxMzU=[三个问题]，给予我们反馈。
* 若发现任何错误，或有其他建议，请在我们的 https://github.com/starknet-edu/starknetbook/issues[Github 仓库发起问题单（Issue）]。
====

== Contributing

[quote, The Starknet Community]
____
*Unleash Your Passion to Perfect StarknetBook*

StarknetBook is a work in progress, and your passion, expertise, and unique insights can help transform it into something truly exceptional. Don't be afraid to challenge the status quo or break the Book! Together, we can create an invaluable resource that empowers countless others.

Embrace the excitement of contributing to something bigger than ourselves. If you see room for improvement, seize the opportunity! Check out our https://github.com/starknet-edu/starknetbook/blob/main/CONTRIBUTING.adoc[guidelines] and join our vibrant community. Let's fearlessly build Starknet! 
____
